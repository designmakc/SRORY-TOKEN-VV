---
alwaysApply: true
---

Always use context7 for code generation, setup, configuration, or library/API docs.

# Vue 3 + Figma Tokens - Cursor Rules

## ⚡ КРАТКАЯ ПАМЯТКА - STORYBOOK ДИНАМИЧЕСКИЙ КОД

**3 ОБЯЗАТЕЛЬНЫХ ШАГА для каждого нового компонента:**

1. **Добавь `generateCode()` в начало stories файла**
2. **Используй `render: (args) => ({...})` в каждой story**
3. **Добавь `parameters.docs.source.transform`**

**Проверь `.storybook/preview.js`:**
```javascript
docs: { source: { type: 'dynamic', state: 'open' } }
```

**БЕЗ ЭТОГО КОД НЕ БУДЕТ ДИНАМИЧЕСКИМ!**

---

## КРИТИЧЕСКИЕ ЗАПРЕТЫ

### НЕТ TAILWIND
- Никаких Tailwind классов (flex, px-4, bg-blue-500, text-sm, rounded)
- Никаких utility классов или @apply

### НЕТ ХАРДКОДА
- Цвета: #3b82f6, rgba()
- Размеры: 16px, 2rem
- Inline стили без токенов
- Вместо gap: 16px; используем семантические токены из T-shirt сетки --gap-none, --gap-3xs, --gap-3xs, --gap-*

### НЕ ПРИДУМЫВАЙ
- Названия токенов
- Значения свойств
- CSS свойства которых нет в Figma

ВАЖЛИВО ДЛЯ ТЕКСТОВИХ ЕЛЕМЕНТІВ:
- Якщо TEXT елемент має "styles" з "name" - використовуй компонент OTypography
- Значення "name" зі стилів використовуй як prop "variant"
- Перетворюй назву стилю: "Header/sm" → "header-sm", "Label/lg" → "label-lg"
- НЕ використовуй окремі CSS властивості для типографіки


## ОБЯЗАТЕЛЬНАЯ СТРУКТУРА

```vue
<template>
  <div :class="['o-component', `o-component--${variant}`]">
    <slot />
  </div>
</template>

<script setup>
import { useDesignTokens } from '@/composables/useDesignTokens';

defineProps({
  variant: {
    type: String,
    default: 'primary',
    validator: (v) => ['primary', 'secondary'].includes(v)
  }
});
</script>

<style scoped>
.o-component {
  background: var(--color-background-primary);
  padding: var(--spacing-md);
}

.o-component--secondary {
  background: var(--color-background-secondary);
}
</style>
```

## WORKFLOW СОЗДАНИЯ КОМПОНЕНТА

### Из Figma (MCP):

1. **MCP Figma** → получи props, размеры, стили
2. **Найди токены**: `npm run tokens:info --search [name]`
3. **ПОКАЖИ МНЕ токены** → ЖДИ ПОДТВЕРЖДЕНИЯ
4. **Создай компонент + Stories**

### Figma размеры:

- **Hug** → `min-width`, `min-height` (растет по содержимому)
- **Fixed** → `width`, `height` (фиксированный)
- **Fill** → `width: 100%` или `flex: 1`

### Если токена нет:

❌ НЕ придумывай  
✅ СПРОСИ у пользователя  
✅ Предложи похожие токены

## ИМЕНОВАНИЕ

### ПРЕФИКС "O" - ОБЯЗАТЕЛЬНО
- **ВСЕ компоненты дизайн-системы** должны иметь префикс "O"
- Это показывает, что компонент использует новую дизайн-систему с токенами
- Компоненты: `OButton.vue`, `OCounter.vue`, `OIconWrap.vue`
- Stories: `OButton.stories.js`, `OCounter.stories.js`
- Импорты: `@/components/OButton.vue`, `@/components/OCounter.vue`

### ПРАВИЛА ПРЕФИКСА "O":
- ✅ **O** = Olymp Design System компонент
- ✅ Всегда используй префикс O для новых компонентов
- ✅ Обновляй существующие компоненты с префиксом O
- ✅ В документации указывай полное название с префиксом
- ❌ НЕ создавай компоненты БЕЗ префикса O

## STORYBOOK TEMPLATE

```javascript
import OComponent from '../src/components/OComponent.vue';
import { useDesignTokens } from '../src/composables/useDesignTokens';

// Функция для генерации динамического кода
const generateCode = (args) => {
  const props = [];
  
  // Добавляем только измененные props (не дефолтные значения)
  if (args.variant && args.variant !== 'primary') props.push(`variant="${args.variant}"`);
  if (args.size && args.size !== 'md') props.push(`size="${args.size}"`);
  if (args.label) props.push(`label="${args.label}"`);
  // Добавь свои props здесь...
  
  // Boolean props
  if (args.isDisabled) props.push(':isDisabled="true"');
  if (args.isLoading) props.push(':isLoading="true"');
  
  // Форматирование для читабельности
  if (props.length <= 2) {
    return `<OComponent ${props.join(' ')} />`;
  } else {
    return `<OComponent\n  ${props.join('\n  ')}\n/>`;
  }
};

export default {
  title: 'Components/ComponentName',
  component: OComponent,
  tags: ['autodocs'], // ОБЯЗАТЕЛЬНО
  argTypes: {
    variant: {
      control: 'select',
      options: ['primary', 'secondary'],
      description: 'Вариант стиля',
      table: {
        defaultValue: { summary: 'primary' }
      }
    }
  },
  decorators: [
    (story, context) => {
      const { setTheme, setBreakpoint } = useDesignTokens();
      if (context.globals.theme) setTheme(context.globals.theme);
      if (context.globals.breakpoint) setBreakpoint(context.globals.breakpoint);
      return { components: { story }, template: '<story />' };
    }
  ]
};

// CSF3 формат с объектами + ДИНАМИЧЕСКИЙ КОД
export const Primary = {
  args: {
    variant: 'primary',
    label: 'Label text'
  },
  render: (args) => ({
    components: { OComponent },
    setup() {
      return { args };
    },
    template: '<OComponent v-bind="args" />'
  }),
  parameters: {
    docs: {
      source: {
        transform: (code, storyContext) => generateCode(storyContext.args),
      },
    },
  },
};
```

### Stories требования:

✅ `tags: ['autodocs']` - ОБЯЗАТЕЛЬНО  
✅ CSF3 формат: `export const Primary = { args: {...} }`  
✅ Decorators для тем  
✅ argTypes с описаниями и table.defaultValue  
✅ **ОБЯЗАТЕЛЬНО** `generateCode()` функция для динамического кода  
✅ **ОБЯЗАТЕЛЬНО** `render: (args) => ({...})` для интерактивности  
✅ **ОБЯЗАТЕЛЬНО** `parameters.docs.source.transform` вместо `code`  
✅ Минимум 3 stories: Primary, AllVariants, Playground  

❌ НЕ используй `.bind({})` - не работает с темами  
❌ НЕ используй статичный `code:` - только `transform:`  
❌ НЕ показывай внутреннюю логику в коде (ref, setup, const)

### Динамический код - ОБЯЗАТЕЛЬНО:

**Всегда добавляй функцию generateCode() в начале файла:**

```javascript
const generateCode = (args) => {
  const props = [];
  
  // Только измененные props
  if (args.variant !== 'primary') props.push(`variant="${args.variant}"`);
  if (args.label) props.push(`label="${args.label}"`);
  if (args.isDisabled) props.push(':isDisabled="true"');
  
  // Форматирование
  if (props.length <= 2) {
    return `<OComponent ${props.join(' ')} />`;
  } else {
    return `<OComponent\n  ${props.join('\n  ')}\n/>`;
  }
};
```

**Всегда используй в stories:**

```javascript
render: (args) => ({
  components: { OComponent },
  setup() { return { args }; },
  template: '<OComponent v-bind="args" />'
}),
parameters: {
  docs: {
    source: {
      transform: (code, storyContext) => generateCode(storyContext.args),
    },
  },
}
```

## ЕДИНИЦЫ ИЗМЕРЕНИЯ

Автоматически добавляются `px` для:
- spacing, padding, margin, gap
- size, width, height
- border, radius

НЕ добавляются для:
-  font-weight, line-height, z-index

## STORYBOOK PREVIEW НАСТРОЙКА

**В `.storybook/preview.js` должно быть:**

```javascript
export const parameters = {
  docs: {
    source: {
      type: 'dynamic',        // ✅ ОБЯЗАТЕЛЬНО для динамического кода
      state: 'open',          // ✅ Показывать код сразу
      excludeDecorators: true,
      format: true,
      language: 'html',
    },
  },
};
```

**Без этой настройки динамический код НЕ РАБОТАЕТ!**

## КОМАНДЫ

```bash
npm run tokens:info --search button    # Поиск
npm run tokens:validate                # Валидация
npm run tokens:generate-docs           # Обновить docs
npm run storybook                      # Запуск
```

## ЧЕК-ЛИСТ

- [ ] Нет Tailwind классов
- [ ] Нет хардкода
- [ ] Все токены существуют
- [ ] Все Props совпадают с Figma!
- [ ] Stories созданы
- [ ] `tags: ['autodocs']` есть
- [ ] **ОБЯЗАТЕЛЬНО** `generateCode()` функция добавлена
- [ ] **ОБЯЗАТЕЛЬНО** `render: (args) => ({...})` для интерактивности
- [ ] **ОБЯЗАТЕЛЬНО** `parameters.docs.source.transform` вместо `code`
- [ ] argTypes имеют table.defaultValue
- [ ] Код динамически меняется при изменении параметров в Controls

## ПРИМЕРЫ

### ❌ НЕПРАВИЛЬНО

```vue
<div class="flex px-4 bg-blue-500">
<div style="padding: 16px">
.button { background: #3b82f6; }
```

### ✅ ПРАВИЛЬНО

```vue
<div :class="['o-button', 'o-button--primary']">

<style>
.o-button {
  padding: var(--button-padding-vertical-lg) var(--button-padding-horizontal-lg);
  background: var(--color-background-button-primary-default);
}
</style>
```

## ОТЛАДКА

### Токены не применяются:

1. DevTools → Elements → :root
2. Проверь CSS переменные
3. Консоль → предупреждения resolver

### Токен не найден:

```javascript
import { findVariablesByPattern } from '@/utils/figma-variables-resolver';
console.log(findVariablesByPattern('button', 'Semantic'));
```

---

## БЫСТРЫЙ СТАРТ: СОЗДАНИЕ НОВОГО КОМПОНЕНТА

### 1. Создай компонент `src/components/O[Name].vue`

```vue
<template>
  <div :class="['o-component', `o-component--${variant}`]">
    <slot />
  </div>
</template>

<script setup>
defineProps({
  variant: {
    type: String,
    default: 'primary',
    validator: (v) => ['primary', 'secondary'].includes(v)
  }
});
</script>

<style scoped>
.o-component {
  background: var(--color-background-primary);
  padding: var(--spacing-md);
}
</style>
```

### 2. Создай stories `stories/O[Name].stories.js`

```javascript
import OComponent from '../src/components/OComponent.vue';
import { useDesignTokens } from '../src/composables/useDesignTokens';

// ✅ ОБЯЗАТЕЛЬНО: Функция для динамического кода
const generateCode = (args) => {
  const props = [];
  if (args.variant !== 'primary') props.push(`variant="${args.variant}"`);
  if (props.length <= 2) return `<OComponent ${props.join(' ')} />`;
  return `<OComponent\n  ${props.join('\n  ')}\n/>`;
};

export default {
  title: 'Components/OComponent',
  component: OComponent,
  tags: ['autodocs'],
  argTypes: {
    variant: {
      control: 'select',
      options: ['primary', 'secondary'],
      description: 'Вариант стиля',
      table: { defaultValue: { summary: 'primary' } }
    }
  },
  decorators: [(story, context) => {
    const { setTheme, setBreakpoint } = useDesignTokens();
    if (context.globals.theme) setTheme(context.globals.theme);
    if (context.globals.breakpoint) setBreakpoint(context.globals.breakpoint);
    return { components: { story }, template: '<story />' };
  }]
};

// ✅ ОБЯЗАТЕЛЬНО: render + transform
export const Primary = {
  args: { variant: 'primary' },
  render: (args) => ({
    components: { OComponent },
    setup() { return { args }; },
    template: '<OComponent v-bind="args" />'
  }),
  parameters: {
    docs: {
      source: {
        transform: (code, storyContext) => generateCode(storyContext.args),
      },
    },
  },
};
```

### 3. Проверь `.storybook/preview.js`

```javascript
export const parameters = {
  docs: {
    source: {
      type: 'dynamic',  // ✅ ОБЯЗАТЕЛЬНО!
      state: 'open',
    },
  },
};
```

### 4. Запусти Storybook

```bash
npm run storybook
```

### 5. Проверь чек-лист

- [ ] Префикс "O" в названии
- [ ] Только токены (без хардкода)
- [ ] `generateCode()` функция есть
- [ ] `render: (args) => ({...})` есть
- [ ] `parameters.docs.source.transform` есть
- [ ] Код динамически меняется в Controls

---

**Главное:** Покажи токены ДО кода. Не придумывай. Не используй Tailwind. Спрашивай если не уверен.

# Storybook Stories Code Display Rules

При создании stories для Vue 3 компонентов в Storybook, следуй этим правилам форматирования кода в `parameters.docs.source.code`:

## Формат для простых компонентов (без вложенности)
```html
<Component prop1="value" prop2="value" />
```

## Формат для компонентов с несколькими атрибутами
```html
<Component
  prop1="value"
  prop2="value"
  prop3="value"
/>
```

## Формат для компонентов с children
```html
<ParentComponent
  label="Заголовок"
  description="Описание"
  direction="vertical"
>
  <ChildComponent label="Значение 1" />
  <ChildComponent label="Значение 2" />
  <ChildComponent label="Значение 3" />
</ParentComponent>
```

## Правила форматирования:

1. **Многострочные атрибуты**: каждый атрибут на новой строке с отступом 2 пробела
2. **Закрывающая скобка**: `>` на той же строке что и последний атрибут
3. **Дочерние элементы**: отступ 2 пробела от родителя
4. **Закрывающий тег**: на уровне открывающего тега (без отступа)
5. **Boolean props**: используй `:prop="true"` или `:prop="false"`, а не просто `prop`
6. **Не показывай**: 
   - v-bind="args"
   - ref(), reactive(), setup()
   - Любую JavaScript логику
   - Значения по умолчанию (если они не важны для примера)

## Структура Story:

```javascript
export const StoryName = {
  args: {
    prop1: 'value',
    prop2: 'value'
  },
  render: args => ({
    components: { Component },
    setup() {
      return { args };
    },
    template: `
      <Component v-bind="args">
        <!-- children -->
      </Component>
    `
  }),
  parameters: {
    docs: {
      source: {
        code: `<Component
  prop1="value"
  prop2="value"
>
  <!-- children -->
</Component>`
      }
    }
  }
};
```

ВАЖНО: 
- `parameters` всегда на одном уровне с `args` и `render`
- Код в `parameters.docs.source.code` должен быть таким, как будто разработчик вручную пишет его в своём проекте
- Только релевантные props, без дефолтных значений

# Storybook Interactive Stories Rules

## Обязательные правила для создания интерактивных stories:

### 1. **Каждая story должна быть интерактивной** - используй `ref()` для состояния
```javascript
export const Interactive = {
  args: {
    isChecked: false,
    label: 'Interactive checkbox'
  },
  render: args => ({
    components: { OCheckbox },
    setup() {
      const checked = ref(args.isChecked);
      return { args, checked };
    },
    template: `
      <OCheckbox 
        v-bind="args" 
        :isChecked="checked"
        @update:isChecked="checked = $event"
      />
    `
  }),
  parameters: {
    docs: {
      source: {
        code: '<OCheckbox :isChecked="false" @update:isChecked="checked = $event" />',
      },
    },
  },
};
```

### 2. **Для чекбоксов/инпутов** - всегда создавай реактивное состояние:
```javascript
setup() {
  const checked = ref(args.isChecked);
  const value = ref(args.value);
  return { args, checked, value };
}
```

### 3. **Привязывай события** - используй @update:propName:
```vue
<OCheckbox 
  :isChecked="checked"
  @update:isChecked="checked = $event"
/>
```

### 4. **Правила для разных типов компонентов:**

#### Чекбоксы:
```javascript
// Состояние
const checked = ref(args.isChecked);

// События
@update:isChecked="checked = $event"
```

#### Радио кнопки:
```javascript
// Состояние
const selectedValue = ref(args.value);

// События
@update:value="selectedValue = $event"
```

#### Счетчики:
```javascript
// Состояние
const count = ref(args.value);

// События
@update:value="count = $event"
```

#### Группы компонентов:
```javascript
// Состояние
const selectedItems = ref(args.selectedItems || []);

// События
@update:selectedItems="selectedItems = $event"
```

### 5. **Обязательные события для интерактивности:**

- **OCheckbox**: `@update:isChecked`
- **ORadioButton**: `@update:value`
- **OCounter**: `@update:value`
- **OCheckboxGroup**: `@update:selectedItems`
- **ORadioButtonGroup**: `@update:selectedValue`

### 6. **Правила отображения кода в docs:**

#### Простой интерактивный компонент:
```html
<OCheckbox :isChecked="false" @update:isChecked="checked = $event" />
```

#### Сложный интерактивный компонент:
```html
<OCheckboxGroup
  :selectedItems="[]"
  @update:selectedItems="selectedItems = $event"
>
  <OCheckbox label="Option 1" />
  <OCheckbox label="Option 2" />
</OCheckboxGroup>
```

### 7. **Чек-лист для интерактивных stories:**

- [ ] Используется `ref()` для состояния
- [ ] События привязаны через `@update:propName`
- [ ] Состояние обновляется в обработчиках событий
- [ ] Код в docs показывает интерактивность
- [ ] Все интерактивные props имеют события
- [ ] Состояние инициализируется из args

### 8. **Пример полной интерактивной story:**

```javascript
export const InteractiveCheckbox = {
  args: {
    isChecked: false,
    label: 'Click me!',
    variant: 'primary'
  },
  render: args => ({
    components: { OCheckbox },
    setup() {
      const checked = ref(args.isChecked);
      return { args, checked };
    },
    template: `
      <OCheckbox 
        v-bind="args" 
        :isChecked="checked"
        @update:isChecked="checked = $event"
      />
    `
  }),
  parameters: {
    docs: {
      source: {
        code: '<OCheckbox :isChecked="false" @update:isChecked="checked = $event" label="Click me!" />',
      },
    },
  },
};
```

**КРИТИЧЕСКИ ВАЖНО:** 
- Каждая story с интерактивными элементами ДОЛЖНА иметь реактивное состояние
- Все события должны быть привязаны через `@update:propName`
- Код в документации должен показывать, как пользователь будет использовать компонент с событиями